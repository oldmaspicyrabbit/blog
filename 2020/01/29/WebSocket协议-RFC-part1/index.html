<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>WebSocket协议 RFC part1 | oldmaspicyrabbit&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="WebSocket协议的官方文档 第一部分">
<meta property="og:type" content="article">
<meta property="og:title" content="WebSocket协议 RFC part1">
<meta property="og:url" content="https://oldmaspicyrabbit.github.io/blog/2020/01/29/WebSocket%E5%8D%8F%E8%AE%AE-RFC-part1/index.html">
<meta property="og:site_name" content="oldmaspicyrabbit&#39;s blog">
<meta property="og:description" content="WebSocket协议的官方文档 第一部分">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-29T18:51:55.000Z">
<meta property="article:modified_time" content="2020-01-31T01:30:07.345Z">
<meta property="article:author" content="oldmaspicyrabbit">
<meta property="article:tag" content="websocket">
<meta property="article:tag" content="rfc">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="oldmaspicyrabbit&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">oldmaspicyrabbit&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://oldmaspicyrabbit.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-WebSocket协议-RFC-part1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/2020/01/29/WebSocket%E5%8D%8F%E8%AE%AE-RFC-part1/" class="article-date">
  <time class="dt-published" datetime="2020-01-29T18:51:55.000Z" itemprop="datePublished">2020-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/blog/categories/web/">web</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      WebSocket协议 RFC part1
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="The-WebSocket-Protocol"><a href="#The-WebSocket-Protocol" class="headerlink" title="The WebSocket Protocol"></a>The WebSocket Protocol</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>   The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code.  The security model used for this is the origin-based security model commonly used by web browsers.  The protocol consists of an opening handshake followed by basic message framing, layered over TCP.  The goal of  this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using   XMLHttpRequest or &amp;lt iframe&amp;gt s and long polling).</p>
<p>摘要<br>WebSocket协议提供了一种全双工通信给处于可控环境中运行着未被信任的代码的客户端和选择与这部分代码相通信的远程主机。用于这种通信的安全模型是源于通常被web浏览器所使用的的安全模型。这种协议包括一种开放的握手协议以及随后的基本消息帧，构建在TCP层上。这项技术的目的是为需要与服务器双向通信基于浏览器的应用提供一种机制，使其不在依赖于打开多个HTTP连接（例如使用XMLHttpRequest,或者&amp;ltiframe&amp;bt以及long polling机制）。</p>
<p>Status of This Memo</p>
<p>   This is an Internet Standards Track document.</p>
<p>   This document is a product of the Internet Engineering Task Force<br>   (IETF).  It represents the consensus of the IETF community.  It has<br>   received public review and has been approved for publication by the<br>   Internet Engineering Steering Group (IESG).  Further information on<br>   Internet Standards is available in Section 2 of RFC 5741.</p>
<p>   Information about the current status of this document, any errata,<br>   and how to provide feedback on it may be obtained at<br>   <a href="http://www.rfc-editor.org/info/rfc6455" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6455</a>.</p>
<p>Copyright Notice</p>
<p>   Copyright (c) 2011 IETF Trust and the persons identified as the<br>   document authors.  All rights reserved.</p>
<p>   This document is subject to BCP 78 and the IETF Trust’s Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info" target="_blank" rel="noopener">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect  to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.<br>从该文档中摘录出的代码组件必须要包含根据the Trust Legal Provisions的4.e节描述的Simplified BSD License文本，且提供是需根据Simplified BSD License中所阐述中的不带任何授权。</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.  Introduction"></a>1.  Introduction</h2><h3 id="1-1-Background"><a href="#1-1-Background" class="headerlink" title="1.1.  Background"></a>1.1.  Background</h3><p>   <em>This section is non-normative.</em></p>
<p>   Historically, creating web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the   server for updates while sending upstream notifications as distinct HTTP calls [RFC6202].<br>历史上，创建需要在一个客户端和一个服务端双向通信的web应用（例如，即时通信和游戏应用）时，不得不大量使用以至于泛滥的HTTP去轮询服务器只为了获得更新，同时以HTTP调用的方式发送上行的通知消息。<br>   This results in a variety of problems:<br>这导致了各种各样的问题：</p>
<ul>
<li>The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client and a new one for each incoming message.<br>服务器被迫针对于每个客户端使用一定数量不同的底层TCP连接：一个用来发送信息给客户端而另一个新的则处理每条接受的消息。 </li>
<li>The wire protocol has a high overhead, with each client-to-server message having an HTTP header.<br>连线协议有一个很高的开销，<del>因为</del>每个client到server的消息都有一个HTTP头。</li>
<li>The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.<br>客户端侧的脚本被迫去维护<del>发送链接到接受链接</del>传出连接和传入连接之间的映射关系来跟踪回复消息。   </li>
</ul>
<p>A simpler solution would be to use a single TCP connection for traffic in both directions.  This is what the WebSocket Protocol provides.  Combined with the WebSocket API [WSAPI], it provides an<br>   alternative to HTTP polling for two-way communication from a web page to a remote server.<br>一个更简单的解决方案<del>可能</del>是使用一个TCP连接来同时实现两个方向的数据流通。这就是WebSocket协议提供的。结合WebSocket API[WSAPI], <del>它提供了一种实现HTTP轮询从一个网页到一个远程服务器的双向通信的替代方案</del>它为从web页面到远程服务器的双向通信提供了HTTP轮询的替代方法。<br>The same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.<br>相同的技术也可以用于各种各样的web应用：游戏，股价行情指示器，<del>多用户应用同时编辑</del>具有同步编辑功能的多用户应用程序，实时显示<del>服务器侧</del>服务器端服务的用户界面，等等。</p>
<p>   The WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication).  Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for<br>   further discussion).  The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work<br>   over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment.  However, the design does not limit WebSocket to<br>   HTTP, and future implementations could use a simpler handshake over a dedicated port without reinventing the entire protocol.  This last point is important because the traffic patterns of interactive<br>   messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.<br>WebSocket协议<del>的设计是为了</del>旨在替代现有的那些使用HTTP作为一个传输层来从现有的基础设施（代理，过滤，认证）获利的双向通信的技术。<del>这些技术被实现成在效率和可靠性之间的交易</del>此类技术是作为效率和可靠性之间的权衡实现的。因为HTTP最初并不是为了被用作双向通信（可以参看RFC6202来做更多深入的讨论）。WebSocket协议尝试在现有HTTP<del>基础设施的背景下</del>基础架构的上下文中来解决现有的双向HTTP技术的目标要求；<del>正因为如此</del>就其本身而言，它被设计成工作在HTTP的80和433端口上，同时支持HTTP代理以及<del>intermediaries</del>中介， 即使这意味着针对当前的环境会有一些复杂性。然而，这种设计并没有限制WebSocket<del>对</del>为HTTP，而且未来实现可以用专门的端口来实现一种更简单的握手协议而不用重新发明整套协议。最后的一点非常重要，因为交互消息的流量模式并不是<del>紧密地</del>完全地和标准的HTTP流量匹配的，<del>是可以引入不常用的负载在一些组件上的</del>可能会在某些组件上引起不寻常的负载。</p>
<h3 id="1-2-Protocol-Overview"><a href="#1-2-Protocol-Overview" class="headerlink" title="1.2.  Protocol Overview"></a>1.2.  Protocol Overview</h3><p>   <em>This section is non-normative.</em></p>
<p>   The protocol has two parts: a handshake and the data transfer.<br>   这套协议有两部分，一次握手和数据传输<br>   The handshake from the client looks as follows:<br>   从客户端的握手看起来如下：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>   The handshake from the server looks as follows:<br>从服务器端看到握手如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<p>   The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format.  The Request-Line and Status-Line productions are defined in [RFC2616].<br>客户端的<del>开头一行</del>开始的行遵循的是Request-Line的格式。服务器的<del>第一行</del>首行则遵循的Status-Line格式。Request-Line和Status-Line的<del>productions</del>结果在RFC2616中定义。  </p>
<p>   An unordered set of header fields comes after the leading line in both cases.  The meaning of these header fields is specified in Section 4 of this document.  Additional header fields may also be<br>   present, such as cookies [RFC6265].  The format and parsing of headers is as defined in [RFC2616].<br>在这两种情况下，一个无序的header字段的集合都会<del>跟在</del>位于第一行之后。这些header字段的含义在<del>这篇</del>本文档的第4节被指明阐述。其他的header字段可能也会出现，例如cookies[RFC6256]. headers的格式以及解析定义在RFC2616中。<br>   Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can,<br>   independently from the other, send data at will.<br>一旦客户端和服务端<del>同时</del>都发送了他们握手信息，<del>而且</del>如果握手<del>是</del>成功<del>的</del>，<del>那么数据传输的部分就开始了</del>则开始数据传输部分。<del>这是一个每一边都能独立于对方按照意愿发送数据的双向通信通道。</del>这是一个双向通信通道，每一方都可以随意发送数据，彼此独立。<br>   After a successful handshake, clients and servers transfer data back and forth in conceptual units referred to in this specification as “messages”.  On the wire, a message is composed of one or more  frames.  The WebSocket message does not necessarily correspond to aparticular network layer framing, as a fragmented message may be coalesced or split by an intermediary.<br>在一次成功的握手之后，客户端和服务器以本规范中<del>所说的</del>称为“messages”的<del>预想的</del>概念单元来回的传输数据。<del>同时</del>在网络上，一条消息是由一个或多个帧构成的。WebSocket消息并不<del>需要对应特殊</del>一定对应于特定网络层帧，而作为一个片段消息可能<del>coalesced合并或者被中介分拆</del>被一个中间层合并或者分割。<br>A frame has an associated type.  Each frame belonging to the same message contains the same type of data.  Broadly speaking, there are types for textual data (which is interpreted as UTF-8 [RFC3629]text), binary data (whose interpretation is left up to theapplication), and control frames (which are not intended to carrydata for the application but instead for protocol-level signaling,such as to signal that the connection should be closed).  Thisversion of the protocol defines six frame types and leaves tenreserved for future use.<br><del>一个</del>帧有<del>一个相关的类型</del>具有相关联的类型。每个属于同一条消息的帧包含相同数据的类型。<del>宽泛的说</del>广义上讲，类型有文本数据（被<del>翻译</del>解释为UTF-8【RFC3629】的文本），二进制数据（它的<del>翻译</del>解释被留给了对应的应用），以及控制帧（并不用来承载应用的数据而是用于协议<del>层面的</del>级信号通知，例如通知连接应该被关闭）。这个版本的协议定义了6个帧类型并<del>空出</del>剩下了十个保留以<del>便</del>备将来使用。<br><del>一个</del>帧有<del>一个相关的类型</del>具有相关联的类型。每个属于同一条消息的帧包含相同数据的类型。<del>宽泛的说</del>广义上讲，类型有文本数据（被<del>翻译</del>解释为UTF-8【RFC3629】的文本），二进制数据（它的<del>翻译</del>解释被留给了对应的应用），以及控制帧（并不用来承载应用的数据而是用于协议<del>层面的</del>级信号通知，例如通知连接应该被关闭）。这个版本的协议定义了6个帧类型并<del>空出</del>剩下了十个保留以<del>便</del>备将来使用。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://oldmaspicyrabbit.github.io/blog/2020/01/29/WebSocket%E5%8D%8F%E8%AE%AE-RFC-part1/" data-id="ck61hqa1r000l7btpgaf65l9j" data-title="WebSocket协议 RFC part1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/websocket/" rel="tag">websocket</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2020/01/30/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          《HTML5 WebSocket权威指南》读书笔记 part 1
        
      </div>
    </a>
  
  
    <a href="/blog/2020/01/28/%E9%83%A8%E7%BD%B2hexo%E5%88%B0GitHub-Pages%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">部署hexo到GitHub Pages的一些问题</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/web/">web</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/web/booknotes/">booknotes</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Github-pages/" rel="tag">Github pages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/websocket/" rel="tag">websocket</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Github-pages/" style="font-size: 10px;">Github pages</a> <a href="/blog/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/blog/tags/websocket/" style="font-size: 20px;">websocket</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/01/31/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-2/">《HTML5 WebSocket权威指南》读书笔记 part 2</a>
          </li>
        
          <li>
            <a href="/blog/2020/01/30/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-1/">《HTML5 WebSocket权威指南》读书笔记 part 1</a>
          </li>
        
          <li>
            <a href="/blog/2020/01/29/WebSocket%E5%8D%8F%E8%AE%AE-RFC-part1/">WebSocket协议 RFC part1</a>
          </li>
        
          <li>
            <a href="/blog/2020/01/28/%E9%83%A8%E7%BD%B2hexo%E5%88%B0GitHub-Pages%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">部署hexo到GitHub Pages的一些问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 oldmaspicyrabbit<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/blog/js/jquery-3.4.1.min.js"></script>



  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>





  </div>
</body>
</html>