<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oldmaspicyrabbit&#39;s blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://oldmaspicyrabbit.github.io/blog/"/>
  <updated>2020-02-03T14:13:45.767Z</updated>
  <id>https://oldmaspicyrabbit.github.io/blog/</id>
  
  <author>
    <name>oldmaspicyrabbit</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>窗外</title>
    <link href="https://oldmaspicyrabbit.github.io/blog/2020/02/03/%E7%AA%97%E5%A4%96/"/>
    <id>https://oldmaspicyrabbit.github.io/blog/2020/02/03/%E7%AA%97%E5%A4%96/</id>
    <published>2020-02-03T22:07:42.000Z</published>
    <updated>2020-02-03T14:13:45.767Z</updated>
    
    <content type="html"><![CDATA[<p>清晨，窗外。<br>阳光照亮了树上的叶子，<br>碧绿而闪亮着生命的光芒。<br>在这早春的微风里，<br>轻轻跳动，<br>诉说着什么。<br>偶尔一两声鸟叫，<br>伴着小河沟里摇曳的芦苇，<br>在发黑的水面上，<br>几片腐烂的荷叶正安静地停驻。<br>跳跃的叶子熙熙瑟瑟的旁边，<br>干瘪黑秃的瘦树歪歪扭扭斜撑着。  </p><p>于2019-nCov肆虐时。</p>]]></content>
    
    <summary type="html">
    
      2019-nCov肆虐时感悟
    
    </summary>
    
    
      <category term="life" scheme="https://oldmaspicyrabbit.github.io/blog/categories/life/"/>
    
    
      <category term="poetry" scheme="https://oldmaspicyrabbit.github.io/blog/tags/poetry/"/>
    
  </entry>
  
  <entry>
    <title>《HTML5 WebSocket权威指南》读书笔记 part 3</title>
    <link href="https://oldmaspicyrabbit.github.io/blog/2020/02/01/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-3/"/>
    <id>https://oldmaspicyrabbit.github.io/blog/2020/02/01/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-3/</id>
    <published>2020-02-01T09:45:00.000Z</published>
    <updated>2020-02-03T14:13:45.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用XMPP构建WebSocket上的即时消息和聊天"><a href="#用XMPP构建WebSocket上的即时消息和聊天" class="headerlink" title="用XMPP构建WebSocket上的即时消息和聊天"></a>用XMPP构建WebSocket上的即时消息和聊天</h1><h2 id="TCP上的互联网应用层协议的典型分层"><a href="#TCP上的互联网应用层协议的典型分层" class="headerlink" title="TCP上的互联网应用层协议的典型分层"></a>TCP上的互联网应用层协议的典型分层</h2><p>展示了TCP上的互联网应用层协议的典型分层方式包含HTTP有两个原因。<br><img src="https://i.niupic.com/images/2020/01/31/6mep.jpg" alt="应用层协议的典型分层"><br>其一，它说明HTTP作为TCP之上的一个应用层协议，可以直接用于Web应用程序中。AJAX应用程序中将HTTP当作所有网络交互的主要或唯一协议。<br>其二，使用WebSocket的应用程序不需要完全忽略HTTP。静态资源总是通过HTTP加载。例如，即使你选择使用WebSocket进行通信，HTML、JavaScript和装饰用户界面的CSS仍然可以通过HTTP提供。因此，在应用协议栈中，你可以在TLS和TCP上使用HTTP及WebSocket。  </p><h2 id="XMPP：XML的流化"><a href="#XMPP：XML的流化" class="headerlink" title="XMPP：XML的流化"></a>XMPP：XML的流化</h2><h3 id="XMPP如何将XML文档语法用于实时通信呢？"><a href="#XMPP如何将XML文档语法用于实时通信呢？" class="headerlink" title="XMPP如何将XML文档语法用于实时通信呢？"></a>XMPP如何将XML文档语法用于实时通信呢？</h3><p>实现方法之一是用单独的文档发送每条消息。然而，这种方法可能出现不必要的冗长文档，浪费资源。<br>另一种方法是将对话当作一个长文档，随着时间推移和消息传输而增长，这是XMPP对文档语法的处理方式。XMPP连接期间的双向对话各方都由一个流化XML文档表示，这个文档在连接终止时结束。该流化文档的根节点是一个＜stream/＞元素。流的最高级子节点是协议的单独数据单位，称作“节”（stanza）。</p><h3 id="选择连接性策略"><a href="#选择连接性策略" class="headerlink" title="选择连接性策略"></a>选择连接性策略</h3><p>用WebSocket连接XMPP服务器有两种方法：修改XMPP服务器以接受WebSocket连接，或者使用代理服务器。选择连接性策略时，理解WebSocket消息（通常由单个WebSocket帧组成）与XMPP节的对齐方式很重要，因为在上述两种方法中对齐的方式是不同的。</p><ul><li>在WebSocket感知的XMPP服务器中，节被一对一映射到WebSocket消息上，每条WebSocket消息包含一节，没有重叠或者碎片。  </li><li>在网关方案中，节与消息的对齐不是必需的，因为它将WebSocket中转到TCP，反之亦然。TCP没有消息边界，所以TCP流可能随意地分割到WebSocket消息中。然而，在网关的情况下，客户端必须理解流化的XML，将字符重组为节。  </li></ul><p>许多IM网络都是“围墙花园”。在特定网络上有账户的用户才能相互交谈。与此相反，Jabber（http：//<a href="http://www.jabber.org）是一个联盟网络，也就是说，如果服务器相互协作，在独立操作服务器上的用户可以通信。" target="_blank" rel="noopener">www.jabber.org）是一个联盟网络，也就是说，如果服务器相互协作，在独立操作服务器上的用户可以通信。</a>  </p><p>连接到Google Talk你可能从Gmail和Google+中熟悉了Google Talk聊天服务，它是JabberIM网络的一部分。有一个公众可以访问的XMPP服务器监听talk.google.com上的5222端口，如果有一个Google账户，你就可以将任何兼容的XMPP客户端连接到该地址并登录。为了将你自己的Web客户端连接到Google Talk，可以将WebSocket代理服务器指向该地址。该服务器需要加密，所以一定要配置代理服务器通过TLS连接。  </p><p>具体例子代码因为涉及到Strophe.js，并没有时间去深入研究，所以不赘述。日后有兴趣再来翻看，验证。</p><h1 id="用STOMP通过WebSocket传递消息"><a href="#用STOMP通过WebSocket传递消息" class="headerlink" title="用STOMP通过WebSocket传递消息"></a>用STOMP通过WebSocket传递消息</h1><p>消息传递（messaging）是一种架构风格，特征是在独立的组件之间发送异步消息，实现松耦合的系统。消息为通信模式提供了一个抽象层，从而为编写网络应用程序提供了一种非常灵活而强大的手段。<br>消息传递中的关键是消息代理和客户端。消息代理（broker）接受客户端的连接，处理来自客户端的消息，并向客户端发送消息。代理还能处理验证、授权、消息加密、可靠消息传递、消息流量控制和分类等工作。当客户端连接到消息代理，它们能够将消息发送给代理，也能接受代理发送给它们的消息。这种模型称为发布/订阅（publish/subscribe），消息代理发布一些消息，客户端订阅所有消息，或者消息的一个子集。<br>PS:STOMP定义中的Text（文本）部分说明该协议是面向文本的。第6章（重点是RFB协议）描述了在WebSocket上使用面向二进制协议的方法。  </p><h2 id="什么是发布-订阅模式"><a href="#什么是发布-订阅模式" class="headerlink" title="什么是发布/订阅模式"></a>什么是发布/订阅模式</h2><p>在消息的世界里，有两种常用的消息传播技术。  </p><ul><li>队列：向单个消费者传递消息的传播机制。任意数量的客户端（发布者）可以向队列发布消息，但是每条消息只能由一个客户端（消费者）接收。<br><img src="https://nats.io/img/documentation/nats-queue.png" alt="Queue模式">  </li><li>主题：向多个消费者传递消息的传播机制。任意数量的客户端（发布者）可以向一个主题发布消息，任何数量的客户端（消费者）可以接收消息。<br><img src="https://nats.io/img/documentation/nats-pub-sub.png" alt="Topic模式"><br>其实还有一种模式，书中没有讲到，请求回复模式。</li><li>请求：向指定多个消费者传递消息的传播机制。客户端（发布者）可以指定向有几个客户端（消费者）可以收到。发送应答模式采用同步调用。<br><img src="https://nats.io/img/documentation/nats-req-rep.png" alt="Request Reply模式">    </li></ul><h2 id="STOMP简介"><a href="#STOMP简介" class="headerlink" title="STOMP简介"></a>STOMP简介</h2><p>STOMP是一种开放消息传递协议，最初被开发用于Apache ActiveMQ，后来被广泛传播到其他系统上。STOMP没有主题或者队列。STOMP消息从不同目标发送和接收，STOMP服务器决定这些目标的行为。STOMP：面向简单（或者流化）文本的消息传递协议。而企业中最广泛使用的消息传递API是JMS：Java Message Service （Java消息服务）。与通过定义线路协议提升互操作性的STOMP不同，JMS只是一个API。STOMP已经用多种语言实现；因为JMS的本质是一个API，它几乎统治了Java世界。</p><p>结合使用STOMP和ActiveMQ。ActiveMQ使用目标名称输出消息传递特性，包括主题和队列、临时目标和层次化订阅。可以任何TCP级协议的相同方式在WebSocket上添加STOMP层，或者进行对齐，使每个STOMP帧正好占据一个WebSocket帧。</p><p>to be continued: 建一个应用程序，使用户能够玩一个流行的游戏—石头-布<br>暂时没有时间完成，但是很有兴趣通过STOMP以及ActiveMQ来实现这个游戏。</p><h1 id="用远程帧缓冲协议实现VNC"><a href="#用远程帧缓冲协议实现VNC" class="headerlink" title="用远程帧缓冲协议实现VNC"></a>用远程帧缓冲协议实现VNC</h1><p>使用VNC（Virtual Network Computing，虚拟网络计算）允许你在任何网络上共享桌面。它本质上允许你远程查看和控制另一台计算机的界面，可以看作和Telnet等价的GUI（图形用户界面）。你还可以将VNC看作一根很长的虚拟电缆，可以用它的鼠标、键盘和视频信号查看和控制另一个桌面。使用WebSocket和远程帧缓冲（RemoteFramebuffer，RFB）协议将VNC扩展到Web上的方法。这章主要是示例作为一个二进制协议，RFB如何以不同于前面两章中讨论过的面向文本协议的方式使用WebSocket API。  </p><h3 id="RFB是什么"><a href="#RFB是什么" class="headerlink" title="RFB是什么"></a>RFB是什么</h3><p>远程帧缓冲协议（RFB）是IETF的一个信息规范（RFC 6143）。虽然它不是正式的标准，但是得到了广泛的应用，有许多可互操作的实现。RFC6143本身已经有10年以上的历史，经过了数次修订。我们先来分解一下协议的定义。帧缓冲（framebuffer）是一个数组，包含了图形化计算机系统显示的所有像素值，是台式机的最小共同模型。因此，RFB是远程访问帧缓冲的一种手段。对于任何有键盘、鼠标和屏幕的系统，都可能有一种利用RFB访问它的方法。<br>RFB是一个二进制协议，传输的是二进制图像数据。数据可以进行压缩，也可以随着高频率的更新流入或者流出服务器。<br> Wireshark支持RFB协议会话的分析，这在调试新的实现时可能很有用。<br><strong>具体示例需要暂时没有时间细究，略过</strong>。<br>需要注意的是当客户端已经可以接收帧缓冲，现在我们在客户端显示这些信息，使客户端能够查看来自RFB服务器（在我们的例子中是TightVNC）的GUI信息。＜canvas＞是HTML5中最重要的新元素之一。＜canvas＞元素支持一个2D绘图API，使HTML5应用程序具备操纵像素图形的能力。<br>在RFB协议中，PointerEvent表示移动或者指点设备（pointing device）按钮的按下或者释放。PointerEvent消息是二进制事件消息，由一个指定发送到服务器的消息种类（如指点设备点击、指点设备移动等）的消息类型字节，一个按钮掩码（携带指点设备1～8号按钮的当前状态，由第0位到第7位表示，0代表按钮弹起，1代表按钮按下），以及两个位置值（由表示屏幕相对的X坐标和Y坐标的无符号短整型组成）组成。</p><h1 id="WebSocket安全性"><a href="#WebSocket安全性" class="headerlink" title="WebSocket安全性"></a>WebSocket安全性</h1><p>在Web上部署应用程序带来了安全性上的挑战，在决定使用WebSocket时你必须加以考虑。</p><table><thead><tr><th>攻击类型</th><th>解决问题的WebSocketAPI或者协议特性</th></tr></thead><tbody><tr><td>拒绝服务</td><td>Origin(源)首标</td></tr><tr><td>连接洪泛拒绝服务</td><td>用Origin首标限制新连接</td></tr><tr><td>代理服务器供给</td><td>屏蔽</td></tr><tr><td>中间人，窃听</td><td>WebSocket安全(wss://)</td></tr><tr><td>### WebSocket是什么（从安全性的角度）</td><td></td></tr><tr><td>WebSocket有许多可取的特性。它是一个简单、标准的全双工协议，开销很低，可以用于构建可伸缩、几乎实时的网络服务器。如果你是一位聪明的计算机专业学生或者稍作回忆，就会知道上述的好处也适用于普通而纯粹的TCP/IP。也就是说，它们是套接字（特别是SOCK_STREAM）的好处，而非WebSocket独有的。那么为什么要在“套接字”（Socket）前加上Web？为什么不简单地在TCP基础上构建传统的互联网应用程序呢？</td><td></td></tr><tr><td>要回答这个问题，我们需要区分“非特权”和“特权”应用程序代码。非特权代码是运行在已知源中的代码，通常是网页中运行的JavaScript。在Web安全性模型中，TCP连接无法被“非特权”代码安全地打开。如果允许非特权应用程序代码打开TCP连接，脚本就可以用伪造的首标发出HTTP请求，使其看上去好像来自不同的源。有了这种伪造首标的能力，相同的脚本可以重新在TCP上实现HTTP以避开规则，从而使控制脚本发起HTTP连接方式的规则变得毫无意义。允许从Web应用程序中发起TCP连接将会破坏源模型。</td><td></td></tr><tr><td>WebSocket连接从非特权代码中发起，因此和AJAX及其他允许在非特权代码中使用的网络功能遵循相同的模型。HTTP握手使连接的初始化在浏览器的控制下进行，允许浏览器设置源首标和保持源模型所需的首标。这样，WebSocket允许应用程序利用轻量级的双向连接实现互联网风格的网络，同时与HTTP应用程序、服务器和沙箱规则并存。</td><td></td></tr><tr><td>从特权代码建立的WebSocket连接一般可以打开任何网络连接；这种能力不是问题（至少对于Web不是问题），因为特权应用总是可以使用任何网络连接，必须由用户安装和执行。原生应用程序不运行于Web源，所以源规则不适用于从特权代码建立的WebSocket。</td><td></td></tr><tr><td>### 限制新连接</td><td></td></tr><tr><td>尽管源首标在HTTP层上阻止连接洪泛（flood），但是在TCP层上仍然有连接洪泛DoS攻击的潜在威胁。即使打开的TCP连接没有携带数据资源，最终被服务器拒绝，大量的客户端也可能淹没服务器。为了避免连接超载，WebSocket API要求浏览器限制打开的新连接。</td><td></td></tr><tr><td>### 屏蔽</td><td></td></tr><tr><td>WebSocket帧是WebSocket消息的组成部分。对从浏览器发往服务器的WebSocket帧进行屏蔽，以混淆帧内容，因为拦截流量的代理服务器可能被WebSocket流量所迷惑。屏蔽还有另一个不常见的微妙原因—它和安全性有关。我们知道有三类代理服务器：</td><td></td></tr><tr><td>+ 转发代理服务器：通常由服务器管理员安装、配置和控制。转发代理服务器将出站请求从内联网转发到互联网。</td><td></td></tr><tr><td>+ 反向代理服务器：通常由服务器管理员安装、配置和控制。反向代理服务器（或者防火墙）一般部署在服务器之前的停火区（DMZ），执行安全功能，以保护内部服务器免遭来自互联网的攻击。</td><td></td></tr><tr><td>+ 透明代理服务器：通常由网络操作员控制。透明代理服务器通常拦截网络通信用于缓冲，或者阻止公司内联网用户因为特定目的而访问Web。网络操作员可能使用透明代理服务器缓冲经常访问的网站，减少网络负载。</td><td></td></tr><tr><td>屏蔽主要是针对透明代理服务器的安全性。<em>HTTP缓存中毒</em>是一种攻击类型，攻击者尝试控制HTTP缓存，用危险的内容代替请求的资源。在WebSocket标准化进程中，一组研究人员撰写了一篇论文，概述了使用HTTP升级请求对透明拦截代理进行理论上的进攻，之后，缓存中毒变成了一个重大的问题。如何避免中毒？WebSocket协议中加入了屏蔽（masking），屏蔽是一种混淆（但不是加密）协议内容，以避免透明拦截代理发生混乱的技术。屏蔽将从浏览器发往WebSocket服务器的每条消息内容与随机字节进行异或运算，转换它们的载荷。</td><td></td></tr><tr><td>和源一样，屏蔽是一种安全特性，它不需要用于对付窃听的加密安全。通信双方和中间人在需要的时候能够理解屏蔽的载荷。然而，对于不理解屏蔽载荷的“中间人”，它们可以避免将WebSocket消息的内容错误地解释为HTTP请求和响应。</td><td></td></tr><tr><td>### TLS加强WebSocket安全性</td><td></td></tr><tr><td>HTTPS和WSS协议非常相似，两者都在通过TCP连接的TLS基础之上运行。为WebSocket线路流量配置TLS加密的方法与HTTP相同：使用证书。WebSocket协议在TCP（和HTTP类似）上运行，WSS连接运行在TLS上，而TLS运行在TCP之上。WebSocket协议与HTTP兼容，所以WebSocket连接使用相同的端口：WebSocket默认端口为80，而WebSocket安全（WSS）默认使用443端口。</td><td></td></tr></tbody></table><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>为了确认通过WebSocket连接到我们服务器的用户身份，WebSocket握手可以包含cookie首标。使用cookie首标使服务器能够在WebSocket验证中使用和验证HTTP请求中相同的cookie。作为替代，验证可以通过应用层协议，在WebSocket升级完成之后进行。XMPP和STOMP等协议层次中内建了识别用户和交换凭据的语义。<br>####应用级安全性<br>应用级安全性描述的是应用程序如何保护自身免遭可能暴露私有信息的攻击。这一级别的安全性保护由应用程序暴露的资源。如果你使用XMPP、STOMP或AMQP（Advanced Message QueueingProtocol，高级消息队列协议）等标准协议，可以在基于WebSocket的系统上利用应用级安全性。权限的配置和具体的服务器相关。  </p><h1 id="部署的考虑"><a href="#部署的考虑" class="headerlink" title="部署的考虑"></a>部署的考虑</h1><p>WebSocket特别相关的部署特性，比如WebSocket模拟、代理和防火墙、负载均衡和容量规划。</p><h3 id="用传输层安全（TLS或SSL）穿越代理和防火墙。"><a href="#用传输层安全（TLS或SSL）穿越代理和防火墙。" class="headerlink" title="用传输层安全（TLS或SSL）穿越代理和防火墙。"></a>用传输层安全（TLS或SSL）穿越代理和防火墙。</h3><p>代理通常分为两类：显式代理和透明代理。当浏览器显式配置为使用代理时，该代理服务器就是显式代理。对于显式代理，你必须向浏览器提供代理主机名称、端口号以及可选的用户名和密码。当浏览器没有意识到流量被代理拦截时，代理服务器就是透明的。即使流量必须穿越显式和透明代理，使用WSS也可能显著增加WebSocket成功的几率。  </p><h3 id="部署TLS"><a href="#部署TLS" class="headerlink" title="部署TLS"></a>部署TLS</h3><p>部署TLS需要用于识别WebSocket服务器的加密数字证书。在生产环境中，这些证书必须由Web浏览器知晓并信任的证书机构（CA）签发 </p><h3 id="WebSocket-ping和pong"><a href="#WebSocket-ping和pong" class="headerlink" title="WebSocket ping和pong"></a>WebSocket ping和pong</h3><p>连接可能因为许多你无法控制的原因而意外关闭。因为WebSocket连接处于TCP连接的上层，发生在TCP级别的连接问题会影响WebSocket连接。在客户端和WebSocket服务器之间的全双工连接中，有时候连接上可能没有数据流。在这个时候，网络中介可能中止连接。<br>使用WebSocket ping和pong能够保持连接打开，为数据流动做好准备。ping和pong可以从打开的WebSocket连接的任一端发起。WebSocket协议支持客户端发起和服务器发起的ping和pong。浏览器或服务器（也可以是两者）都可以在合适的时间间隔内发起ping和pong，保持连接活跃。<strong>注意，我们说的是浏览器而不是WebSocket客户端</strong>：<strong>WebSocket API目前不支持客户端发起的ping和pong</strong>。</p><h3 id="WebSocket缓冲和流量控制"><a href="#WebSocket缓冲和流量控制" class="headerlink" title="WebSocket缓冲和流量控制"></a>WebSocket缓冲和流量控制</h3><p>由于WebSocket应用程序使用全双工连接，你可以控制应用程序向服务器发送数据的速率，这也称作“流量控制”（throttling）。流量控制有助于避免可能受到其他限制影响的网络饱和或者瓶颈，例如互联网带宽和服务器CPU的限制。WebSocket API可以用WebSocket bufferedAmount特性（我们在第2章中讨论过）控制应用程序向服务器发送数据的速率。bufferedAmount特性表示在队列中尚未传输到服务器的字节数。<br>你还可以限制客户端到服务器的连接数，允许服务器根据预先定义的设置确定是接受还是拒绝客户端连接。  </p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>为了评估系统的性能，你还可以在必要的时候配置监控工具，跟踪用户活动、服务器性能，以及终止客户端会话  </p><h3 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h3><p>在架构中实施WebSocket可以建立灵活、可伸缩的框架。尽管有这样的灵活性，你仍然必须为部署需求做计划，包括规模的考虑，特别是与硬件容量相关的因素。这些领域包括服务器的内存和CPU（不管是启用WebSocket的后端服务器，还是使WebSocket流量能够在客户端和后端服务器之间流动的网关），以及网络优化。<br>此外，有许多基于云的WebSocket服务产品，它们实际上让WebSocket开发人员不需要考虑容量规划。  </p><h3 id="套接字限制"><a href="#套接字限制" class="headerlink" title="套接字限制"></a>套接字限制</h3><p>WebSocket服务器同时打开许多连接。你应该意识到，如果运行一台没有更改过操作系统设置的服务器，可能无法维持几千个以上的套接字。即使还有丰富的CPU和内存资源，你也将会看到无法打开更多文件的错误报告。（记住，在UNIX中，几乎所有资源都是文件，包括套接字！即使没有使用磁盘，也可能看到关于文件的错误信息。）操作系统限制每个用户打开的文件数，默认情况下，这一限制值相当低。这些限制是为了避免滥用许多用户争用相同资源的共享系统。<br>例如，在Liunx上，ulimit-a命令显示当前用户限制，包括最大允许打开文件数。很幸运，在Linux上可以提高这一限制。</p><h3 id="WebSocket应用程序部署检查列表"><a href="#WebSocket应用程序部署检查列表" class="headerlink" title="WebSocket应用程序部署检查列表"></a>WebSocket应用程序部署检查列表</h3><table><thead><tr><th>规划项目</th><th>备注</th></tr></thead><tbody><tr><td>WebSocket模拟和备用手段</td><td>确定用户的浏览器和版本确定备用策略是否必要。如果是，使用填充、插件后者Comet备用措施</td></tr><tr><td>反向代理和负载平衡</td><td>确定你想要公开的端口，确定必须使用反向代理的服务器，确定是否可以在firewall上打开一个端口，从而确定是否应该使用反向连接性，确定网络资源负载需求，包括服务器和客户端连接</td></tr><tr><td>用TLS穿越代理和防火墙</td><td>确定可能扰乱WebSocket流量的代理和防火墙；确定因为安全或者连接性原因使用TLS</td></tr><tr><td>持续连接</td><td>确定你想要监控的连接，设置ping间隔以避免连接超时</td></tr><tr><td>缓存和流量控制</td><td>确定流量控制能够改进性能的地方</td></tr><tr><td>监控</td><td>确定监控区域</td></tr><tr><td>硬件容量规划</td><td>确定WebSocket服务器的内存和cpu需求；确定宽带需求；确定服务器的磁盘需求；确定基于云超是否更适合于你的应用部署</td></tr><tr><td>套接字限制</td><td>确定系统需要的鬓发套接字连接数，确定服务器的套接字限制</td></tr></tbody></table><h1 id="WebSocket流量和资源"><a href="#WebSocket流量和资源" class="headerlink" title="WebSocket流量和资源"></a>WebSocket流量和资源</h1><h3 id="WebSocket流量"><a href="#WebSocket流量" class="headerlink" title="WebSocket流量"></a>WebSocket流量</h3><p>研究3个方便的工具：</p><ul><li>Google Chrome开发者工具：Chrome自带的一组HTML5应用程序，你可以用它检查、调试和优化Web应用程序。</li><li>Google Chrome Network Internals（或称“net-internals”）：一组检查网络行为（包括DNS查找、SPDY、HTTP缓存和WebSocket）的工具。<br>在地址栏中键入<strong>chrome：//net-internals</strong>。网络内部工具（net-internals）的用处之一是检查TCP套接字事件。这些TCP套接字用于传输WebSocket和浏览器使用的其他通信协议。<br>说明 在Google Chrome中，URL about：about重定向到chrome：//about。其他浏览器如Mozilla Firefox在它们的about：about页面中列出有用的URL。该页面显示下列内部Chrome实用工具：<br>chrome：//appcache-internals<br>chrome：//blob-internals<br>chrome：//bookmarks<br>chrome：//cache<br>chrome：//chrome-urls<br>chrome：//crashes<br>chrome：//credits<br>chrome：//dns<br>chrome：//downloads<br>chrome：//extensions<br>chrome：//flags<br>chrome：//flash<br>chrome：//gpu-internals<br>chrome：//history<br>chrome：//ipc<br>chrome：//inspect<br>chrome：//media-internals<br>chrome：//memory<br>chrome：//nacl<br>chrome：//net-internals<br>chrome：//view-http-cache<br>chrome：//newtab<br>chrome：//omnibox<br>chrome：//plugins<br>chrome：//policy<br>chrome：//predictors<br>chrome：//profiler<br>chrome：//quota-internals<br>chrome：//settings<br>chrome：//stats<br>chrome：//sync-internals<br>chrome：//terms<br>chrome：//tracing<br>chrome：//version<br>chrome：//print</li><li>Wireshark：用于分析网络协议流量的工具<h3 id="WebSocket服务器"><a href="#WebSocket服务器" class="headerlink" title="WebSocket服务器"></a>WebSocket服务器</h3>虽然你可以让服务器接受WebSocket连接或者编写自己的Websocket服务器，但是有一些现有的实现能够让你在开发WebSocket应用程序时更加轻松。书中列出可用的WebSocket服务器（该列表由http：//refcardz.dzone.com/refcardz/html5-websocket提供）：<br>Alchemy-Websockets（.NET）：<br>http：//alchemywebsockets.net/Apache ActiveMQ：<br>http：//activemq.apache.org/apache-websocket（Apache模块）:<br>https：//github.com/disconnect/ apache-websocket#readmeAPE Project（C）:<br>http：//<a href="http://www.ape-project.org/Autobahn（虚拟用具）" target="_blank" rel="noopener">www.ape-project.org/Autobahn（虚拟用具）</a>:<br>http：//autobahn.ws/Caucho Resin（Java）:<br>http：//<a href="http://www.caucho.com/Cowboy" target="_blank" rel="noopener">www.caucho.com/Cowboy</a>:<br>https：//github.com/extend/cowboyCramp（Ruby）:<br>http：//cramp.in/Diffusion（商业产品）http：//<a href="http://www.pushtechnology.com/homeEM-WebSocket（Ruby）" target="_blank" rel="noopener">www.pushtechnology.com/homeEM-WebSocket（Ruby）</a>:<br>https：//github.com/igrigorik/em-websocketExtendible WebSocket Server（PHP）:<br>http：//github.com/wkjagt/Extendible-Web-Socket-Servergevent-websocket（Python）:<br>http：//<a href="http://www.gelens.org/code/gevent-websocket/GlassFish（Java）" target="_blank" rel="noopener">www.gelens.org/code/gevent-websocket/GlassFish（Java）</a>:<br>https：//glassfish.java.net/Goliath（Ruby）:<br>https：//github.com/postrank-labs/goliathJetty（Java）:<br>http：//jetty.codehaus.org/jetty/jWebsocket（Java）:<br>http：//jwebsocket.org/Kaazing WebSocket Gateway（商业产品）:<br>http：//kaazing.com/libwebsockets（C）:<br>http：//git.warmcat.com/cgi-bin/cgit/libwebsockets/Misultin（Erlang）:<br>https：//github.com/ostinelli/misultinnet.websocket（Go）:<br>http：//code.google.com/p/go.net/websocketNetty（Java）:<br>http：//netty.io/Nugget（.NET）:<br>http：//nugget.codeplex.com/phpdaemon（PHP）:<br>http：//phpdaemon.net/Pusher（云服务）:<br>http：//pusher.com/pywebsockets（Python）:<br>http：//code.google.com/p/pywebsocket/RabbitMQ（Erlang）:<br>https：//github.com/videlalvaro/rabbitmq-websocketsSocket.io（Node.js）:<br>http：//socket.io/SockJS-node（Node）:<br>https：//github.com/sockjs/sockjs-node</li></ul>]]></content>
    
    <summary type="html">
    
      《HTML5 WebSocket权威指南》读书笔记第二部分，主要是为什么要用websocket例子的搭建，最主要都是代码验证了构建远程JS控制台
    
    </summary>
    
    
      <category term="web" scheme="https://oldmaspicyrabbit.github.io/blog/categories/web/"/>
    
      <category term="booknotes" scheme="https://oldmaspicyrabbit.github.io/blog/categories/web/booknotes/"/>
    
    
      <category term="websocket" scheme="https://oldmaspicyrabbit.github.io/blog/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>《HTML5 WebSocket权威指南》读书笔记 part 2</title>
    <link href="https://oldmaspicyrabbit.github.io/blog/2020/01/31/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-2/"/>
    <id>https://oldmaspicyrabbit.github.io/blog/2020/01/31/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-2/</id>
    <published>2020-01-31T09:25:40.000Z</published>
    <updated>2020-02-03T14:13:45.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用JS和Node-js编写WebSocket服务器API"><a href="#用JS和Node-js编写WebSocket服务器API" class="headerlink" title="用JS和Node.js编写WebSocket服务器API"></a>用JS和Node.js编写WebSocket服务器API</h1><p>用Node构建简单的WebSocket服务器，主要是用JS和Node.js编写WebSocket服务器API，最主要是实现一个供服务器使用的WebSocket的对象，而这个对象因为是在服务器使用的，所以需要提供的：<br>1.构造函数完成握手过程，提供listen()方法构建connection成功<br>2.外部方法主要是通过connection的send()和close()<br>3.内部方法有handleFrame, processBuffer, doSend分别用于处理数据帧并发送 。<br>查了javascript中的WebSocket对象–<strong>Provides the API for creating and managing a WebSocket connection to a server</strong>, as well as for sending and receiving data on the connection.  </p><h1 id="用的上述新服务器API构建一个回显服务器"><a href="#用的上述新服务器API构建一个回显服务器" class="headerlink" title="用的上述新服务器API构建一个回显服务器"></a>用的上述新服务器API构建一个回显服务器</h1><p>listen端口，并在callback函数中完成对data和close事件的处理函数的定义和注册。在data事件中调用提供的WebSocket的API中的send方法进行数据回显。</p><h1 id="应用：构建远程Javascript控制台"><a href="#应用：构建远程Javascript控制台" class="headerlink" title="应用：构建远程Javascript控制台"></a>应用：构建远程Javascript控制台</h1><p>控制台也称为REPL(Read Eval Print Loop)利用Node.js的repl模块，添加一个自定义的eval()函数。添加WebSocket，可以通过互联网远程控制一个Web应用程序。使用这个WebSocket驱动的控制台，我们将能从一个命令行接口远程求取表达式的值。更好的是，我们可以输入一个表达式，并看到每个并发连接的客户端求得的表达式值。</p><p>觉得这个例子很妙，但是书上的server code太多了，现在node有现成的websocket的模块ws，可以用于构建websocket server。改写书中的code，<br>WebSocket服务器的code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const WebSocket &#x3D; require(&#39;ws&#39;);</span><br><span class="line">var repl &#x3D; require(&quot;repl&quot;);</span><br><span class="line">var connections &#x3D; Object.create(null);</span><br><span class="line">var remoteMultiEval &#x3D; function(cmd, context, filename, callback) &#123;</span><br><span class="line">    for (var c in connections) &#123;</span><br><span class="line">        console.log(&quot;\t connection:&quot; + c + &quot; ready to send:\t&quot; );</span><br><span class="line">        console.log(&quot;\t connection is:&quot; + connections[c] + &quot;\t&quot; );</span><br><span class="line">        connections[c].send(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    callback(null, &quot;(result pending)&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const wssvr &#x3D; new WebSocket.Server(&#123;host:&quot;localhost&quot;, port: 9999 &#125;);</span><br><span class="line">wssvr.on(&#39;connection&#39;, function connection(connsock, request) &#123;</span><br><span class="line">    connsock.id &#x3D; Math.random().toString().substr(2);</span><br><span class="line">    connections[connsock.id] &#x3D; connsock;</span><br><span class="line">    console.log(&quot;new connection: &quot; + connsock.id);    </span><br><span class="line">    connsock.on(&#39;message&#39;, function incoming(message) &#123;</span><br><span class="line">      console.log(&quot;\t&quot; + connsock.id + &quot;:\t&quot; + message);</span><br><span class="line">    &#125;);</span><br><span class="line">    connsock.on(&quot;close&quot;, function() &#123;</span><br><span class="line">        &#x2F;&#x2F;remove connection</span><br><span class="line">        delete connections[connsock.id];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">repl.start(&#123;&quot;eval&quot;: remoteMultiEval&#125;);</span><br></pre></td></tr></table></figure><p>websocket客户端的code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;titile&gt;WebSocket REPL Client&lt;&#x2F;titile&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;h2&gt;Websocket REPL Client&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var url &#x3D; &quot;ws:&#x2F;&#x2F;localhost:9999&#x2F;repl&quot;;</span><br><span class="line">var ws &#x3D; new WebSocket(url);</span><br><span class="line">ws.onmessage &#x3D; function(e) &#123;</span><br><span class="line">    console.log(&quot;command&quot;, e.data);</span><br><span class="line">    try&#123;</span><br><span class="line">        var result &#x3D; eval(e.data);</span><br><span class="line">        ws.send(result.toString());</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        ws.send(err.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>在server端launch服务器，然后enter 命令“navigator.userAgent”，便可以看到client端的运行后回传回来的结果，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wssample&gt; node .\websocket-repl-svr-ws.js</span><br><span class="line">&gt; new connection: 5649403465277831</span><br><span class="line">&gt; navigator.userAgent</span><br><span class="line">         connection:5649403465277831 ready to send:</span><br><span class="line">         connection is:[object Object]</span><br><span class="line">&#39;(result pending)&#39;</span><br><span class="line">&gt;       5649403465277831:       Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko&#x2F;20100101 Firefox&#x2F;72.0</span><br></pre></td></tr></table></figure><p>而在browser client端的console，output则是<img src="https://i.niupic.com/images/2020/01/31/6mca.PNG" alt="browser结果"></p>]]></content>
    
    <summary type="html">
    
      《HTML5 WebSocket权威指南》读书笔记第二部分，主要是为什么要用websocket例子的搭建，最主要都是代码验证了构建远程JS控制台
    
    </summary>
    
    
      <category term="web" scheme="https://oldmaspicyrabbit.github.io/blog/categories/web/"/>
    
      <category term="booknotes" scheme="https://oldmaspicyrabbit.github.io/blog/categories/web/booknotes/"/>
    
    
      <category term="websocket" scheme="https://oldmaspicyrabbit.github.io/blog/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>《HTML5 WebSocket权威指南》读书笔记 part 1</title>
    <link href="https://oldmaspicyrabbit.github.io/blog/2020/01/30/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-1/"/>
    <id>https://oldmaspicyrabbit.github.io/blog/2020/01/30/%E3%80%8AHTML5-WebSocket%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-part-1/</id>
    <published>2020-01-30T18:29:30.000Z</published>
    <updated>2020-02-03T14:13:45.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Websocket-之前的世界："><a href="#Websocket-之前的世界：" class="headerlink" title="Websocket 之前的世界："></a>Websocket 之前的世界：</h1><p>轮询polling：因为不清楚什么时候有更新，无法掌握好确切的轮询时间间隔，结果是，在低信息率的情况下，你可能打开或者关闭许多不必要的连接。<br>长轮询long polling,也称comet，或反向ajax，以及“挂起GET”和“搁置POST”:<br>具体的long polling可以参考图<img src="https://camo.githubusercontent.com/ee4304f7d599f41425937f3f322e944f5ff4412a/687474703a2f2f7777772e706c616e74756d6c2e636f6d2f706c616e74756d6c2f70726f78793f666d743d737667267372633d68747470733a2f2f676973742e67697468756275736572636f6e74656e742e636f6d2f6c7563747275646561752f65346333383962306531363536343066646464302f7261772f" alt="long polling"><br>流化技术中，客户端发送一个请求，服务器发送并维护一个持续更新和保持打开（可以是无限或者规定的时间段（涉及到超时断开））的开放响应（因为服务器不发送响应的完成信息，所以一直在响应前述的请求）。每当服务器有需要交付给客户端的信息时，它就更新响应。会有五个问题，<br>第一，如果数据量大，客户端同样要不断重连，性能和轮询没差；<br>第二，缺乏实现标准；<br>第三，因为响应一直未完成，代理和防火墙反应缓慢会导致信息延迟增加；<br>第四，每一种情况下，客户端都必须等待请求返回，才能发出后续的请求，而这显著地增加了延迟；<br>第五，包含了附加额外的header中的字段以及延迟，开销也很大。<br>对比polling的几种机制，如下图:<img src="http://blog.outsider.ne.kr/attach/1/1340436424.gif.pagespeed.ce._mFuj4R9Nb.gif" alt="various polling"></p><h1 id="Websocket-之后的世界："><a href="#Websocket-之后的世界：" class="headerlink" title="Websocket 之后的世界："></a>Websocket 之后的世界：</h1><p>HTML5规范的连接性部分包含了WebSocket。WebSocket是一种自然的全双工、双向、单套接字连接。WebSocket减少了延迟，因为一旦建立起WebSocket连接，服务器可以在消息可用时发送它们。</p><p>暂时性的理解websocket：借助于http实现的类似于底层socket的技术，所以既通过了http，又有底层socket的灵活性。<br>相关技术：WebSocket的重点是改进Web应用程序前端和服务器之间的通信，而SPDY优化的是应用程序内容和静态页面的交付。HTTP和WebSocket之间的不同是架构性的，而不是增量的。<br>WebSocket和SPDY是相互补充的，你可以将SPDY扩充的HTTP连接升级为WebSocket  </p><h1 id="Websocket-API"><a href="#Websocket-API" class="headerlink" title="Websocket API"></a>Websocket API</h1><p>主要描述了WebSocket中的事件，方法，和特性<br>WebSocket的连接通过在客户端和服务器之间第一次握手时将HTTP协议升级到WebSocket协议来完成，这已工作在相同的底层TCP连接上进行。而WebSocket完全是事件驱动的，这点我觉得可以想象socket的处理过程，epoll对读写事件的驱动的自动处理。<br>WebSocket API定义了两种 URL方案（URL Scheme），WS和WSS（WebSocket Secure）,分别用于客户端和服务器之间的非加密和加密流量。  </p><h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><p>限定URL是ws开头。WebSocket的最大好处之一是能在WebSocket上建立广泛使用的协议层次（将在第3章～第6章介绍），使你可以完成许多出色的工作，例如将传统的桌面应用程序带到Web中。<br>客户发送带有协议名称的Sec-WebSocket-Protocol首标。服务器选择0个或者1个协议，响应一个带有和客户请求相同的协议名称的Sec-WebSocket-Protocol首标；  </p><h2 id="WebSocket事件"><a href="#WebSocket事件" class="headerlink" title="WebSocket事件"></a>WebSocket事件</h2><p>WebSocket编程遵循异步编程，即连接打开，应用程序就简单地监听事件，只要为WebSocket对象添加回调函数，或者用DOM方法addEventListener()添加事件监听器。<br>有四个不同的事件-open,messsage,error,close  </p><ul><li>open事件<br>open事件触发时，握手已经完成，WebSocket已经准备发放数据了。  </li><li>message事件<br>WebSocketAPI只输出完整的消息而不是WebSocket帧，message事件在接收到消息时触发，可以处理文本消息，二进制（Blob或者ArrayBuffer）消息。</li><li>error事件<br>error事件在响应意外故障时触发。对应为回调函数onerror.</li><li>close事件<br>close事件有3个有用的属性(property), wasClean、close和error。<br>事件相关的可以参见<a href="http://www.w3.org/TR/websockets/" target="_blank" rel="noopener">官网</a> </li></ul><h2 id="WebSocket方法"><a href="#WebSocket方法" class="headerlink" title="WebSocket方法"></a>WebSocket方法</h2><p>WebSocket对象有两个方法：send()和close().</p><ul><li>send方法<br>在调用onopen监听器之后，调用onclose监听器之前调用send（）方法.<br>如果想发送消息响应另一个事件，可以检查WebSocket readyState属性，并选择只在套接字打开时发送数据.<br>Blob对象在与JavaScript File API结合使用以发送和接收文件时特别有用，这些文件主要有多媒体文件、图像、视频和音频。</li><li>close方法<br>使用close方法，可以关闭WebSocket连接。</li></ul><h2 id="WebSocket对象特性"><a href="#WebSocket对象特性" class="headerlink" title="WebSocket对象特性"></a>WebSocket对象特性</h2><p>readyState特性：是描述连接状态的四个值，WebSocket.CONNECTING, WebSocket.OPEN,WebSocket.CLOSING,WebSocket.CLOSED<br>bufferedAmount特性：检查已经进入队列，但是尚未发送到服务器的字节数。<br>protocol特性：它让服务器知道客户端理解并可在WebSocket上使用的协议。包含在打开握手期间WebSocket服务器选择的协议名。</p><p>注意，如何确定browser是否支持websocket，在JS控制台求取window.WebSocket表达式的值。如果你看到WebSocket构造函数对象，就意味着浏览器对WebSocket有原生支持。<br>WebSocket是连接Web世界和互联网世界(更具体额说是TCP/IP)的桥梁。</p><p>Chome可以在开发者工具中的Network的选项卡中查看WebSocket的流量。</p><h1 id="Websocket协议"><a href="#Websocket协议" class="headerlink" title="Websocket协议"></a>Websocket协议</h1><h2 id="WebSocket握手"><a href="#WebSocket握手" class="headerlink" title="WebSocket握手"></a>WebSocket握手</h2><ul><li>初始握手，websocket连接都始于一个HTTP请求，其中最主要的是header中的一个字段Upgrade,用来标明客户端将吧连接升级到不同的协议。除非</li></ul><p><em>服务器响应101代码</em>、<br><em>Upgrade首标</em>、<br><em>Sec-WebSocket-Accept首标</em>，<br>否则WebSocket连接不能成功。Sec-WebSocket-Accept响应首标的值从Sec-WebSocket-Key请求首标继承而来，包含一个特殊的响应键值，必须与客户端的预期精确匹配。</p><ul><li>需要注意的是如何计算响应的键值：<br>响应函数从客户端发送的Sec-WebSocket-Key首标中取得键值，并在Sec-WebSocket-Accept首标中返回根据客户端预期计算的键值。代码清单3-3使用Node.js加密API计算键值和后缀组合的SHA1散列值。</li><li>消息格式<br>客户端和服务器可以在任何时候相互发送消息。这些消息在网络上用标记消息之间边界并包括简洁的类型信息的二进制语法表示。更准确地说，这些二进制首标标记另一个单位—帧（frame）—之间的边界。下面展示了WebSocket帧头<img src="https://i.niupic.com/images/2020/01/30/6maz.png" alt="WebSocket帧头"><br>WebSocket帧化代码负责：操作码/长度/解码/文本/屏蔽/多帧消息</li><li>WebSocket关闭握手<br>当WebSocket关闭时，终止连接的端点可以发送一个数字代码，以及一个表示选择关闭套接字原因的字符串。</li><li>对其他协议的支持<br>用WebSocket API协商更高层协议的方法。在网络层上，这些协议用Sec-WebSocket-Protocol首标协商。</li><li>扩展<br>和协议一样，扩展也使用Sec-首标协商。连接的客户端发送一个Sec-WebSocket-Extensions首标，包含所支持的扩展名称。</li></ul>]]></content>
    
    <summary type="html">
    
      《HTML5 WebSocket权威指南》读书笔记第一部分，主要是为什么要用websocket，以及描述websocket是什么，后面部分都是实际应用例子，读完后若有必要再整理
    
    </summary>
    
    
      <category term="web" scheme="https://oldmaspicyrabbit.github.io/blog/categories/web/"/>
    
      <category term="booknotes" scheme="https://oldmaspicyrabbit.github.io/blog/categories/web/booknotes/"/>
    
    
      <category term="websocket" scheme="https://oldmaspicyrabbit.github.io/blog/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket协议 RFC part1</title>
    <link href="https://oldmaspicyrabbit.github.io/blog/2020/01/29/WebSocket%E5%8D%8F%E8%AE%AE-RFC-part1/"/>
    <id>https://oldmaspicyrabbit.github.io/blog/2020/01/29/WebSocket%E5%8D%8F%E8%AE%AE-RFC-part1/</id>
    <published>2020-01-29T18:51:55.000Z</published>
    <updated>2020-02-03T14:13:45.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-WebSocket-Protocol"><a href="#The-WebSocket-Protocol" class="headerlink" title="The WebSocket Protocol"></a>The WebSocket Protocol</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>   The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code.  The security model used for this is the origin-based security model commonly used by web browsers.  The protocol consists of an opening handshake followed by basic message framing, layered over TCP.  The goal of  this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using   XMLHttpRequest or &amp;lt iframe&amp;gt s and long polling).</p><p>摘要<br>WebSocket协议提供了一种全双工通信给处于可控环境中运行着未被信任的代码的客户端和选择与这部分代码相通信的远程主机。用于这种通信的安全模型是源于通常被web浏览器所使用的的安全模型。这种协议包括一种开放的握手协议以及随后的基本消息帧，构建在TCP层上。这项技术的目的是为需要与服务器双向通信基于浏览器的应用提供一种机制，使其不在依赖于打开多个HTTP连接（例如使用XMLHttpRequest,或者&amp;ltiframe&amp;bt以及long polling机制）。</p><p>Status of This Memo</p><p>   This is an Internet Standards Track document.</p><p>   This document is a product of the Internet Engineering Task Force<br>   (IETF).  It represents the consensus of the IETF community.  It has<br>   received public review and has been approved for publication by the<br>   Internet Engineering Steering Group (IESG).  Further information on<br>   Internet Standards is available in Section 2 of RFC 5741.</p><p>   Information about the current status of this document, any errata,<br>   and how to provide feedback on it may be obtained at<br>   <a href="http://www.rfc-editor.org/info/rfc6455" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6455</a>.</p><p>Copyright Notice</p><p>   Copyright (c) 2011 IETF Trust and the persons identified as the<br>   document authors.  All rights reserved.</p><p>   This document is subject to BCP 78 and the IETF Trust’s Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info" target="_blank" rel="noopener">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect  to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.<br>从该文档中摘录出的代码组件必须要包含根据the Trust Legal Provisions的4.e节描述的Simplified BSD License文本，且提供是需根据Simplified BSD License中所阐述中的不带任何授权。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.  Introduction"></a>1.  Introduction</h2><h3 id="1-1-Background"><a href="#1-1-Background" class="headerlink" title="1.1.  Background"></a>1.1.  Background</h3><p>   <em>This section is non-normative.</em></p><p>   Historically, creating web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the   server for updates while sending upstream notifications as distinct HTTP calls [RFC6202].<br>历史上，创建需要在一个客户端和一个服务端双向通信的web应用（例如，即时通信和游戏应用）时，不得不大量使用以至于泛滥的HTTP去轮询服务器只为了获得更新，同时以HTTP调用的方式发送上行的通知消息。<br>   This results in a variety of problems:<br>这导致了各种各样的问题：</p><ul><li>The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client and a new one for each incoming message.<br>服务器被迫针对于每个客户端使用一定数量不同的底层TCP连接：一个用来发送信息给客户端而另一个新的则处理每条接受的消息。 </li><li>The wire protocol has a high overhead, with each client-to-server message having an HTTP header.<br>连线协议有一个很高的开销，<del>因为</del>每个client到server的消息都有一个HTTP头。</li><li>The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.<br>客户端侧的脚本被迫去维护<del>发送链接到接受链接</del>传出连接和传入连接之间的映射关系来跟踪回复消息。   </li></ul><p>A simpler solution would be to use a single TCP connection for traffic in both directions.  This is what the WebSocket Protocol provides.  Combined with the WebSocket API [WSAPI], it provides an<br>   alternative to HTTP polling for two-way communication from a web page to a remote server.<br>一个更简单的解决方案<del>可能</del>是使用一个TCP连接来同时实现两个方向的数据流通。这就是WebSocket协议提供的。结合WebSocket API[WSAPI], <del>它提供了一种实现HTTP轮询从一个网页到一个远程服务器的双向通信的替代方案</del>它为从web页面到远程服务器的双向通信提供了HTTP轮询的替代方法。<br>The same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.<br>相同的技术也可以用于各种各样的web应用：游戏，股价行情指示器，<del>多用户应用同时编辑</del>具有同步编辑功能的多用户应用程序，实时显示<del>服务器侧</del>服务器端服务的用户界面，等等。</p><p>   The WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication).  Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for<br>   further discussion).  The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work<br>   over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment.  However, the design does not limit WebSocket to<br>   HTTP, and future implementations could use a simpler handshake over a dedicated port without reinventing the entire protocol.  This last point is important because the traffic patterns of interactive<br>   messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.<br>WebSocket协议<del>的设计是为了</del>旨在替代现有的那些使用HTTP作为一个传输层来从现有的基础设施（代理，过滤，认证）获利的双向通信的技术。<del>这些技术被实现成在效率和可靠性之间的交易</del>此类技术是作为效率和可靠性之间的权衡实现的。因为HTTP最初并不是为了被用作双向通信（可以参看RFC6202来做更多深入的讨论）。WebSocket协议尝试在现有HTTP<del>基础设施的背景下</del>基础架构的上下文中来解决现有的双向HTTP技术的目标要求；<del>正因为如此</del>就其本身而言，它被设计成工作在HTTP的80和433端口上，同时支持HTTP代理以及<del>intermediaries</del>中介， 即使这意味着针对当前的环境会有一些复杂性。然而，这种设计并没有限制WebSocket<del>对</del>为HTTP，而且未来实现可以用专门的端口来实现一种更简单的握手协议而不用重新发明整套协议。最后的一点非常重要，因为交互消息的流量模式并不是<del>紧密地</del>完全地和标准的HTTP流量匹配的，<del>是可以引入不常用的负载在一些组件上的</del>可能会在某些组件上引起不寻常的负载。</p><h3 id="1-2-Protocol-Overview"><a href="#1-2-Protocol-Overview" class="headerlink" title="1.2.  Protocol Overview"></a>1.2.  Protocol Overview</h3><p>   <em>This section is non-normative.</em></p><p>   The protocol has two parts: a handshake and the data transfer.<br>   这套协议有两部分，一次握手和数据传输<br>   The handshake from the client looks as follows:<br>   从客户端的握手看起来如下：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p>   The handshake from the server looks as follows:<br>从服务器端看到握手如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>   The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format.  The Request-Line and Status-Line productions are defined in [RFC2616].<br>客户端的<del>开头一行</del>开始的行遵循的是Request-Line的格式。服务器的<del>第一行</del>首行则遵循的Status-Line格式。Request-Line和Status-Line的<del>productions</del>结果在RFC2616中定义。  </p><p>   An unordered set of header fields comes after the leading line in both cases.  The meaning of these header fields is specified in Section 4 of this document.  Additional header fields may also be<br>   present, such as cookies [RFC6265].  The format and parsing of headers is as defined in [RFC2616].<br>在这两种情况下，一个无序的header字段的集合都会<del>跟在</del>位于第一行之后。这些header字段的含义在<del>这篇</del>本文档的第4节被指明阐述。其他的header字段可能也会出现，例如cookies[RFC6256]. headers的格式以及解析定义在RFC2616中。<br>   Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can,<br>   independently from the other, send data at will.<br>一旦客户端和服务端<del>同时</del>都发送了他们握手信息，<del>而且</del>如果握手<del>是</del>成功<del>的</del>，<del>那么数据传输的部分就开始了</del>则开始数据传输部分。<del>这是一个每一边都能独立于对方按照意愿发送数据的双向通信通道。</del>这是一个双向通信通道，每一方都可以随意发送数据，彼此独立。<br>   After a successful handshake, clients and servers transfer data back and forth in conceptual units referred to in this specification as “messages”.  On the wire, a message is composed of one or more  frames.  The WebSocket message does not necessarily correspond to aparticular network layer framing, as a fragmented message may be coalesced or split by an intermediary.<br>在一次成功的握手之后，客户端和服务器以本规范中<del>所说的</del>称为“messages”的<del>预想的</del>概念单元来回的传输数据。<del>同时</del>在网络上，一条消息是由一个或多个帧构成的。WebSocket消息并不<del>需要对应特殊</del>一定对应于特定网络层帧，而作为一个片段消息可能<del>coalesced合并或者被中介分拆</del>被一个中间层合并或者分割。<br>A frame has an associated type.  Each frame belonging to the same message contains the same type of data.  Broadly speaking, there are types for textual data (which is interpreted as UTF-8 [RFC3629]text), binary data (whose interpretation is left up to theapplication), and control frames (which are not intended to carrydata for the application but instead for protocol-level signaling,such as to signal that the connection should be closed).  Thisversion of the protocol defines six frame types and leaves tenreserved for future use.<br><del>一个</del>帧有<del>一个相关的类型</del>具有相关联的类型。每个属于同一条消息的帧包含相同数据的类型。<del>宽泛的说</del>广义上讲，类型有文本数据（被<del>翻译</del>解释为UTF-8【RFC3629】的文本），二进制数据（它的<del>翻译</del>解释被留给了对应的应用），以及控制帧（并不用来承载应用的数据而是用于协议<del>层面的</del>级信号通知，例如通知连接应该被关闭）。这个版本的协议定义了6个帧类型并<del>空出</del>剩下了十个保留以<del>便</del>备将来使用。<br><del>一个</del>帧有<del>一个相关的类型</del>具有相关联的类型。每个属于同一条消息的帧包含相同数据的类型。<del>宽泛的说</del>广义上讲，类型有文本数据（被<del>翻译</del>解释为UTF-8【RFC3629】的文本），二进制数据（它的<del>翻译</del>解释被留给了对应的应用），以及控制帧（并不用来承载应用的数据而是用于协议<del>层面的</del>级信号通知，例如通知连接应该被关闭）。这个版本的协议定义了6个帧类型并<del>空出</del>剩下了十个保留以<del>便</del>备将来使用。  </p>]]></content>
    
    <summary type="html">
    
      WebSocket协议的官方文档 第一部分
    
    </summary>
    
    
      <category term="web" scheme="https://oldmaspicyrabbit.github.io/blog/categories/web/"/>
    
    
      <category term="websocket" scheme="https://oldmaspicyrabbit.github.io/blog/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>部署hexo到GitHub Pages的一些问题</title>
    <link href="https://oldmaspicyrabbit.github.io/blog/2020/01/28/%E9%83%A8%E7%BD%B2hexo%E5%88%B0GitHub-Pages%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>https://oldmaspicyrabbit.github.io/blog/2020/01/28/%E9%83%A8%E7%BD%B2hexo%E5%88%B0GitHub-Pages%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2020-01-28T22:31:44.000Z</published>
    <updated>2020-02-03T14:13:45.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>第一次使用hexo搭建借助github pages搭建博客网站，如何搭建网上的教程有很多。<br>简要的描述，主要有三个部分：</p><ul><li>安装node, hexo, gitbash</li><li>创建hexo的站点文件，主要是hexo init </li><li>将hexo的站点文件host到 github pages<br>第一部分安装相关软件的，我暂时没碰到什么问题，所以直接略过了，下面会介绍后面两个部分中遇到的问题以及我是如何解决的。</li></ul><h2 id="创建hexo的站点文件–问题以及解决方法"><a href="#创建hexo的站点文件–问题以及解决方法" class="headerlink" title="创建hexo的站点文件–问题以及解决方法"></a>创建hexo的站点文件–问题以及解决方法</h2><p>在第二部分，创建hexo站点文件时，执行hexo init出现了几个问题，在网上没有怎么碰到：</p><h3 id="问题1：git-clone-时-error-RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errno-10054"><a href="#问题1：git-clone-时-error-RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errno-10054" class="headerlink" title="问题1：git clone 时 error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054"></a>问题1：git clone 时 error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</h3><p>这部分具体记录已经丢失了，但是出现的问题日志，主要是这一条，导致每次git clone都失败，hexo init直接失败。<br>WARN git clone failed. Copying data instead<br>WARN Failed to install dependencies. Please run ‘npm install’ manually!<br><strong>解决的办法</strong>：<br>在网上搜索了下，虽然给出的直接解决办法是 git config http.sslVerify “false”<br>但是似乎总是会在download dependencies的时候卡住，还是会失败。<br>所以后面继续搜索，找到了hexo的github上的issue的<a href="https://github.com/hexojs/hexo/issues/2646" target="_blank" rel="noopener">类似问题-hexo init,but no file created</a>的回复：<br>Could you please try to clone the repo <a href="https://github.com/hexojs/hexo-starter" target="_blank" rel="noopener">https://github.com/hexojs/hexo-starter</a> , then run npm install inside the folder?<br>验证过后，发现问题似乎解决了，站点文件都有，唯一的问题是gitclone的文件夹下会有.git文件，而我们是需要import到自己的github的repository中的，而且如果直接git clone的话，文件夹名仍然是hexo-starter，所以需要用git clone <a href="https://github.com/hexojs/hexo-starter" target="_blank" rel="noopener">https://github.com/hexojs/hexo-starter</a>  yourFolderName, 文件夹名会是youFolderName。</p><h3 id="问题2-hexo-generate时提示WARN-No-layout-index-html-1037且hexo-s后无法正常显示，而是显示的是空白页面。"><a href="#问题2-hexo-generate时提示WARN-No-layout-index-html-1037且hexo-s后无法正常显示，而是显示的是空白页面。" class="headerlink" title="问题2: hexo generate时提示WARN No layout: index.html #1037且hexo s后无法正常显示，而是显示的是空白页面。"></a>问题2: hexo generate时提示WARN No layout: index.html #1037且hexo s后无法正常显示，而是显示的是空白页面。</h3><p><strong>解决的办法</strong>：在github上找到了类似的<a href="https://github.com/hexojs/hexo/issues/1037" target="_blank" rel="noopener">问题-WARN No layout: index.html</a>,解决办法也很简单粗暴：<br>Under the folder, enter: git clone <a href="https://github.com/hexojs/hexo-theme-landscape.git" target="_blank" rel="noopener">https://github.com/hexojs/hexo-theme-landscape.git</a> themes/landscape<br>那么很显然，这个问题是因为缺少themes文件造成的html无法正常生成，我在后面用Trivis CI进行build时检查build完后的deploy文件也验证发现了类似的问题，generate出来的index.html文件都是0字节，显示无法正常显示。</p><h2 id="使用Trivis-CI进行build后的branch来host站点–问题以及解决方法"><a href="#使用Trivis-CI进行build后的branch来host站点–问题以及解决方法" class="headerlink" title="使用Trivis CI进行build后的branch来host站点–问题以及解决方法"></a>使用Trivis CI进行build后的branch来host站点–问题以及解决方法</h2><p>这里需要首先弄清两个问题，github pages的种类有几种？hexo和Trivis CI和github的workflow到底是怎么样的？</p><h3 id="问题1：hexo的guidelines上的说明In-your-GitHub-repo’s-setting-navigate-to-“GitHub-Pages”-section-and-change-Source-to-gh-pages-branch-根本没法实现，因为Source是灰的"><a href="#问题1：hexo的guidelines上的说明In-your-GitHub-repo’s-setting-navigate-to-“GitHub-Pages”-section-and-change-Source-to-gh-pages-branch-根本没法实现，因为Source是灰的" class="headerlink" title="问题1：hexo的guidelines上的说明In your GitHub repo’s setting, navigate to “GitHub Pages” section and change Source to gh-pages branch.根本没法实现，因为Source是灰的"></a>问题1：hexo的guidelines上的说明In your GitHub repo’s setting, navigate to “GitHub Pages” section and change Source to gh-pages branch.根本没法实现，因为Source是灰的</h3><p>我被这个问题坑了很久，因为前面提到的themes的files缺失导致html文件时空的，我一直以为是这个原因导致的，后来才发现这根本是两个问题，前面的是build就有的问题。而这里这个是deployment的问题，是两回事。<br><strong>解决的办法</strong>：在hexo官网上上找到了<a href="https://hexo.io/docs/github-pages" target="_blank" rel="noopener">解决办法-Project page</a><br>If you prefer to have a project page on GitHub:<br>    1. Navigate to your repo on GitHub. Go to the Settings tab. Change the Repository name so your blog is available at username.github.io/repository, repository can be any name, like blog or hexo.<br>    2. Edit your _config.yml, change the root: value to the /<repository>/ (must starts and ends with a slash, without the brackets).Commit and push.<br>所以 My Steps:<br>1.Change the repository name into “blog”, then the repository change to oldmaspicyrabbit/blog<br>2.Change the source from “master” to “gh_pages”<br>3.github pages will hint: Your site is published at <a href="https://oldmaspicyrabbit.github.io/blog/">https://oldmaspicyrabbit.github.io/blog/</a><br>4.open _config.yml file, change “root: /“ to “root: /blog/“  </p>]]></content>
    
    <summary type="html">
    
      主要记录在借助hexo和GitHub Pages的部署过程中遇到的问题以及解决办法
    
    </summary>
    
    
      <category term="hexo" scheme="https://oldmaspicyrabbit.github.io/blog/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://oldmaspicyrabbit.github.io/blog/tags/hexo/"/>
    
      <category term="Github pages" scheme="https://oldmaspicyrabbit.github.io/blog/tags/Github-pages/"/>
    
  </entry>
  
</feed>
