<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oldmaspicyrabbit&#39;s blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://oldmaspicyrabbit.github.io/blog/"/>
  <updated>2020-01-29T10:54:54.185Z</updated>
  <id>https://oldmaspicyrabbit.github.io/blog/</id>
  
  <author>
    <name>oldmaspicyrabbit</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket协议 RFC part1</title>
    <link href="https://oldmaspicyrabbit.github.io/blog/2020/01/29/WebSocket%E5%8D%8F%E8%AE%AE-RFC-part1/"/>
    <id>https://oldmaspicyrabbit.github.io/blog/2020/01/29/WebSocket%E5%8D%8F%E8%AE%AE-RFC-part1/</id>
    <published>2020-01-29T18:51:55.000Z</published>
    <updated>2020-01-29T10:54:54.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-WebSocket-Protocol"><a href="#The-WebSocket-Protocol" class="headerlink" title="The WebSocket Protocol"></a>The WebSocket Protocol</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>   The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host that has opted-in to communications from that code.  The security model used for this is the origin-based security model commonly used by web browsers.  The protocol consists of an opening handshake followed by basic message framing, layered over TCP.  The goal of  this technology is to provide a mechanism for browser-based applications that need two-way communication with servers that does not rely on opening multiple HTTP connections (e.g., using   XMLHttpRequest or &amp;lt iframe&amp;gt s and long polling).</p><p>摘要<br>WebSocket协议提供了一种全双工通信给处于可控环境中运行着未被信任的代码的客户端和选择与这部分代码相通信的远程主机。用于这种通信的安全模型是源于通常被web浏览器所使用的的安全模型。这种协议包括一种开放的握手协议以及随后的基本消息帧，构建在TCP层上。这项技术的目的是为需要与服务器双向通信基于浏览器的应用提供一种机制，使其不在依赖于打开多个HTTP连接（例如使用XMLHttpRequest,或者&amp;ltiframe&amp;bt以及long polling机制）。</p><p>Status of This Memo</p><p>   This is an Internet Standards Track document.</p><p>   This document is a product of the Internet Engineering Task Force<br>   (IETF).  It represents the consensus of the IETF community.  It has<br>   received public review and has been approved for publication by the<br>   Internet Engineering Steering Group (IESG).  Further information on<br>   Internet Standards is available in Section 2 of RFC 5741.</p><p>   Information about the current status of this document, any errata,<br>   and how to provide feedback on it may be obtained at<br>   <a href="http://www.rfc-editor.org/info/rfc6455" target="_blank" rel="noopener">http://www.rfc-editor.org/info/rfc6455</a>.</p><p>Copyright Notice</p><p>   Copyright (c) 2011 IETF Trust and the persons identified as the<br>   document authors.  All rights reserved.</p><p>   This document is subject to BCP 78 and the IETF Trust’s Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info" target="_blank" rel="noopener">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect  to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.<br>从该文档中摘录出的代码组件必须要包含根据the Trust Legal Provisions的4.e节描述的Simplified BSD License文本，且提供是需根据Simplified BSD License中所阐述中的不带任何授权。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.  Introduction"></a>1.  Introduction</h2><h3 id="1-1-Background"><a href="#1-1-Background" class="headerlink" title="1.1.  Background"></a>1.1.  Background</h3><p>   <em>This section is non-normative.</em></p><p>   Historically, creating web applications that need bidirectional communication between a client and a server (e.g., instant messaging and gaming applications) has required an abuse of HTTP to poll the   server for updates while sending upstream notifications as distinct HTTP calls [RFC6202].<br>历史上，创建需要在一个客户端和一个服务端双向通信的web应用（例如，即时通信和游戏应用）时，不得不大量使用以至于泛滥的HTTP去轮询服务器只为了获得更新，同时以HTTP调用的方式发送上行的通知消息。<br>   This results in a variety of problems:<br>这导致了各种各样的问题：</p><ul><li>The server is forced to use a number of different underlying TCP connections for each client: one for sending information to the client and a new one for each incoming message.<br>服务器被迫针对于每个客户端使用一定数量不同的底层TCP连接：一个用来发送信息给客户端而另一个新的则处理每条接受的消息。 </li><li>The wire protocol has a high overhead, with each client-to-server message having an HTTP header.<br>连线协议有一个很高的开销，<del>因为</del>每个client到server的消息都有一个HTTP头。</li><li>The client-side script is forced to maintain a mapping from the outgoing connections to the incoming connection to track replies.<br>客户端侧的脚本被迫去维护<del>发送链接到接受链接</del>传出连接和传入连接之间的映射关系来跟踪回复消息。   </li></ul><p>A simpler solution would be to use a single TCP connection for traffic in both directions.  This is what the WebSocket Protocol provides.  Combined with the WebSocket API [WSAPI], it provides an<br>   alternative to HTTP polling for two-way communication from a web page to a remote server.<br>一个更简单的解决方案<del>可能</del>是使用一个TCP连接来同时实现两个方向的数据流通。这就是WebSocket协议提供的。结合WebSocket API[WSAPI], <del>它提供了一种实现HTTP轮询从一个网页到一个远程服务器的双向通信的替代方案</del>它为从web页面到远程服务器的双向通信提供了HTTP轮询的替代方法。<br>The same technique can be used for a variety of web applications: games, stock tickers, multiuser applications with simultaneous editing, user interfaces exposing server-side services in real time, etc.<br>相同的技术也可以用于各种各样的web应用：游戏，股价行情指示器，<del>多用户应用同时编辑</del>具有同步编辑功能的多用户应用程序，实时显示<del>服务器侧</del>服务器端服务的用户界面，等等。</p><p>   The WebSocket Protocol is designed to supersede existing bidirectional communication technologies that use HTTP as a transport layer to benefit from existing infrastructure (proxies, filtering, authentication).  Such technologies were implemented as trade-offs between efficiency and reliability because HTTP was not initially meant to be used for bidirectional communication (see [RFC6202] for<br>   further discussion).  The WebSocket Protocol attempts to address the goals of existing bidirectional HTTP technologies in the context of the existing HTTP infrastructure; as such, it is designed to work<br>   over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries, even if this implies some complexity specific to the current environment.  However, the design does not limit WebSocket to<br>   HTTP, and future implementations could use a simpler handshake over a dedicated port without reinventing the entire protocol.  This last point is important because the traffic patterns of interactive<br>   messaging do not closely match standard HTTP traffic and can induce unusual loads on some components.<br>WebSocket协议<del>的设计是为了</del>旨在替代现有的那些使用HTTP作为一个传输层来从现有的基础设施（代理，过滤，认证）获利的双向通信的技术。<del>这些技术被实现成在效率和可靠性之间的交易</del>此类技术是作为效率和可靠性之间的权衡实现的。因为HTTP最初并不是为了被用作双向通信（可以参看RFC6202来做更多深入的讨论）。WebSocket协议尝试在现有HTTP<del>基础设施的背景下</del>基础架构的上下文中来解决现有的双向HTTP技术的目标要求；<del>正因为如此</del>就其本身而言，它被设计成工作在HTTP的80和433端口上，同时支持HTTP代理以及<del>intermediaries</del>中介， 即使这意味着针对当前的环境会有一些复杂性。然而，这种设计并没有限制WebSocket<del>对</del>为HTTP，而且未来实现可以用专门的端口来实现一种更简单的握手协议而不用重新发明整套协议。最后的一点非常重要，因为交互消息的流量模式并不是<del>紧密地</del>完全地和标准的HTTP流量匹配的，<del>是可以引入不常用的负载在一些组件上的</del>可能会在某些组件上引起不寻常的负载。</p><h3 id="1-2-Protocol-Overview"><a href="#1-2-Protocol-Overview" class="headerlink" title="1.2.  Protocol Overview"></a>1.2.  Protocol Overview</h3><p>   <em>This section is non-normative.</em></p><p>   The protocol has two parts: a handshake and the data transfer.<br>   这套协议有两部分，一次握手和数据传输<br>   The handshake from the client looks as follows:<br>   从客户端的握手看起来如下：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ&#x3D;&#x3D;</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure><p>   The handshake from the server looks as follows:<br>从服务器端看到握手如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure><p>   The leading line from the client follows the Request-Line format. The leading line from the server follows the Status-Line format.  The Request-Line and Status-Line productions are defined in [RFC2616].<br>客户端的<del>开头一行</del>开始的行遵循的是Request-Line的格式。服务器的<del>第一行</del>首行则遵循的Status-Line格式。Request-Line和Status-Line的<del>productions</del>结果在RFC2616中定义。  </p><p>   An unordered set of header fields comes after the leading line in both cases.  The meaning of these header fields is specified in Section 4 of this document.  Additional header fields may also be<br>   present, such as cookies [RFC6265].  The format and parsing of headers is as defined in [RFC2616].<br>在这两种情况下，一个无序的header字段的集合都会<del>跟在</del>位于第一行之后。这些header字段的含义在<del>这篇</del>本文档的第4节被指明阐述。其他的header字段可能也会出现，例如cookies[RFC6256]. headers的格式以及解析定义在RFC2616中。<br>   Once the client and server have both sent their handshakes, and if the handshake was successful, then the data transfer part starts. This is a two-way communication channel where each side can,<br>   independently from the other, send data at will.<br>一旦客户端和服务端<del>同时</del>都发送了他们握手信息，<del>而且</del>如果握手<del>是</del>成功<del>的</del>，<del>那么数据传输的部分就开始了</del>则开始数据传输部分。<del>这是一个每一边都能独立于对方按照意愿发送数据的双向通信通道。</del>这是一个双向通信通道，每一方都可以随意发送数据，彼此独立。<br>   After a successful handshake, clients and servers transfer data back and forth in conceptual units referred to in this specification as “messages”.  On the wire, a message is composed of one or more  frames.  The WebSocket message does not necessarily correspond to aparticular network layer framing, as a fragmented message may be coalesced or split by an intermediary.<br>在一次成功的握手之后，客户端和服务器以本规范中<del>所说的</del>称为“messages”的<del>预想的</del>概念单元来回的传输数据。<del>同时</del>在网络上，一条消息是由一个或多个帧构成的。WebSocket消息并不<del>需要对应特殊</del>一定对应于特定网络层帧，而作为一个片段消息可能<del>coalesced合并或者被中介分拆</del>被一个中间层合并或者分割。<br>A frame has an associated type.  Each frame belonging to the same message contains the same type of data.  Broadly speaking, there are types for textual data (which is interpreted as UTF-8 [RFC3629]text), binary data (whose interpretation is left up to theapplication), and control frames (which are not intended to carrydata for the application but instead for protocol-level signaling,such as to signal that the connection should be closed).  Thisversion of the protocol defines six frame types and leaves tenreserved for future use.<br><del>一个</del>帧有<del>一个相关的类型</del>具有相关联的类型。每个属于同一条消息的帧包含相同数据的类型。<del>宽泛的说</del>广义上讲，类型有文本数据（被<del>翻译</del>解释为UTF-8【RFC3629】的文本），二进制数据（它的<del>翻译</del>解释被留给了对应的应用），以及控制帧（并不用来承载应用的数据而是用于协议<del>层面的</del>级信号通知，例如通知连接应该被关闭）。这个版本的协议定义了6个帧类型并<del>空出</del>剩下了十个保留以<del>便</del>备将来使用。<br><del>一个</del>帧有<del>一个相关的类型</del>具有相关联的类型。每个属于同一条消息的帧包含相同数据的类型。<del>宽泛的说</del>广义上讲，类型有文本数据（被<del>翻译</del>解释为UTF-8【RFC3629】的文本），二进制数据（它的<del>翻译</del>解释被留给了对应的应用），以及控制帧（并不用来承载应用的数据而是用于协议<del>层面的</del>级信号通知，例如通知连接应该被关闭）。这个版本的协议定义了6个帧类型并<del>空出</del>剩下了十个保留以<del>便</del>备将来使用。  </p>]]></content>
    
    <summary type="html">
    
      WebSocket协议的官方文档 第一部分
    
    </summary>
    
    
      <category term="web" scheme="https://oldmaspicyrabbit.github.io/blog/categories/web/"/>
    
    
      <category term="websocket" scheme="https://oldmaspicyrabbit.github.io/blog/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>部署hexo到GitHub Pages的一些问题</title>
    <link href="https://oldmaspicyrabbit.github.io/blog/2020/01/28/%E9%83%A8%E7%BD%B2hexo%E5%88%B0GitHub-Pages%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>https://oldmaspicyrabbit.github.io/blog/2020/01/28/%E9%83%A8%E7%BD%B2hexo%E5%88%B0GitHub-Pages%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</id>
    <published>2020-01-28T22:31:44.000Z</published>
    <updated>2020-01-29T10:54:54.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>第一次使用hexo搭建借助github pages搭建博客网站，如何搭建网上的教程有很多。<br>简要的描述，主要有三个部分：</p><ul><li>安装node, hexo, gitbash</li><li>创建hexo的站点文件，主要是hexo init </li><li>将hexo的站点文件host到 github pages<br>第一部分安装相关软件的，我暂时没碰到什么问题，所以直接略过了，下面会介绍后面两个部分中遇到的问题以及我是如何解决的。</li></ul><h2 id="创建hexo的站点文件–问题以及解决方法"><a href="#创建hexo的站点文件–问题以及解决方法" class="headerlink" title="创建hexo的站点文件–问题以及解决方法"></a>创建hexo的站点文件–问题以及解决方法</h2><p>在第二部分，创建hexo站点文件时，执行hexo init出现了几个问题，在网上没有怎么碰到：</p><h3 id="问题1：git-clone-时-error-RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errno-10054"><a href="#问题1：git-clone-时-error-RPC-failed-curl-56-OpenSSL-SSL-read-SSL-ERROR-SYSCALL-errno-10054" class="headerlink" title="问题1：git clone 时 error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054"></a>问题1：git clone 时 error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</h3><p>这部分具体记录已经丢失了，但是出现的问题日志，主要是这一条，导致每次git clone都失败，hexo init直接失败。<br>WARN git clone failed. Copying data instead<br>WARN Failed to install dependencies. Please run ‘npm install’ manually!<br><strong>解决的办法</strong>：<br>在网上搜索了下，虽然给出的直接解决办法是 git config http.sslVerify “false”<br>但是似乎总是会在download dependencies的时候卡住，还是会失败。<br>所以后面继续搜索，找到了hexo的github上的issue的<a href="https://github.com/hexojs/hexo/issues/2646" target="_blank" rel="noopener">类似问题-hexo init,but no file created</a>的回复：<br>Could you please try to clone the repo <a href="https://github.com/hexojs/hexo-starter" target="_blank" rel="noopener">https://github.com/hexojs/hexo-starter</a> , then run npm install inside the folder?<br>验证过后，发现问题似乎解决了，站点文件都有，唯一的问题是gitclone的文件夹下会有.git文件，而我们是需要import到自己的github的repository中的，而且如果直接git clone的话，文件夹名仍然是hexo-starter，所以需要用git clone <a href="https://github.com/hexojs/hexo-starter" target="_blank" rel="noopener">https://github.com/hexojs/hexo-starter</a>  yourFolderName, 文件夹名会是youFolderName。</p><h3 id="问题2-hexo-generate时提示WARN-No-layout-index-html-1037且hexo-s后无法正常显示，而是显示的是空白页面。"><a href="#问题2-hexo-generate时提示WARN-No-layout-index-html-1037且hexo-s后无法正常显示，而是显示的是空白页面。" class="headerlink" title="问题2: hexo generate时提示WARN No layout: index.html #1037且hexo s后无法正常显示，而是显示的是空白页面。"></a>问题2: hexo generate时提示WARN No layout: index.html #1037且hexo s后无法正常显示，而是显示的是空白页面。</h3><p><strong>解决的办法</strong>：在github上找到了类似的<a href="https://github.com/hexojs/hexo/issues/1037" target="_blank" rel="noopener">问题-WARN No layout: index.html</a>,解决办法也很简单粗暴：<br>Under the folder, enter: git clone <a href="https://github.com/hexojs/hexo-theme-landscape.git" target="_blank" rel="noopener">https://github.com/hexojs/hexo-theme-landscape.git</a> themes/landscape<br>那么很显然，这个问题是因为缺少themes文件造成的html无法正常生成，我在后面用Trivis CI进行build时检查build完后的deploy文件也验证发现了类似的问题，generate出来的index.html文件都是0字节，显示无法正常显示。</p><h2 id="使用Trivis-CI进行build后的branch来host站点–问题以及解决方法"><a href="#使用Trivis-CI进行build后的branch来host站点–问题以及解决方法" class="headerlink" title="使用Trivis CI进行build后的branch来host站点–问题以及解决方法"></a>使用Trivis CI进行build后的branch来host站点–问题以及解决方法</h2><p>这里需要首先弄清两个问题，github pages的种类有几种？hexo和Trivis CI和github的workflow到底是怎么样的？</p><h3 id="问题1：hexo的guidelines上的说明In-your-GitHub-repo’s-setting-navigate-to-“GitHub-Pages”-section-and-change-Source-to-gh-pages-branch-根本没法实现，因为Source是灰的"><a href="#问题1：hexo的guidelines上的说明In-your-GitHub-repo’s-setting-navigate-to-“GitHub-Pages”-section-and-change-Source-to-gh-pages-branch-根本没法实现，因为Source是灰的" class="headerlink" title="问题1：hexo的guidelines上的说明In your GitHub repo’s setting, navigate to “GitHub Pages” section and change Source to gh-pages branch.根本没法实现，因为Source是灰的"></a>问题1：hexo的guidelines上的说明In your GitHub repo’s setting, navigate to “GitHub Pages” section and change Source to gh-pages branch.根本没法实现，因为Source是灰的</h3><p>我被这个问题坑了很久，因为前面提到的themes的files缺失导致html文件时空的，我一直以为是这个原因导致的，后来才发现这根本是两个问题，前面的是build就有的问题。而这里这个是deployment的问题，是两回事。<br><strong>解决的办法</strong>：在hexo官网上上找到了<a href="https://hexo.io/docs/github-pages" target="_blank" rel="noopener">解决办法-Project page</a><br>If you prefer to have a project page on GitHub:<br>    1. Navigate to your repo on GitHub. Go to the Settings tab. Change the Repository name so your blog is available at username.github.io/repository, repository can be any name, like blog or hexo.<br>    2. Edit your _config.yml, change the root: value to the /<repository>/ (must starts and ends with a slash, without the brackets).Commit and push.<br>所以 My Steps:<br>1.Change the repository name into “blog”, then the repository change to oldmaspicyrabbit/blog<br>2.Change the source from “master” to “gh_pages”<br>3.github pages will hint: Your site is published at <a href="https://oldmaspicyrabbit.github.io/blog/">https://oldmaspicyrabbit.github.io/blog/</a><br>4.open _config.yml file, change “root: /“ to “root: /blog/“  </p>]]></content>
    
    <summary type="html">
    
      主要记录在借助hexo和GitHub Pages的部署过程中遇到的问题以及解决办法
    
    </summary>
    
    
      <category term="hexo" scheme="https://oldmaspicyrabbit.github.io/blog/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://oldmaspicyrabbit.github.io/blog/tags/hexo/"/>
    
      <category term="Github pages" scheme="https://oldmaspicyrabbit.github.io/blog/tags/Github-pages/"/>
    
  </entry>
  
</feed>
